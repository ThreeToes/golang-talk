# How to be a not nice person in Go

Stephen Gream
6th April, 2021

## About me
.image images/buffdoge.jpeg

## About me
* Got into programming as script kiddie
* Studied at ANU
* Moved to Melbourne in 2012
* Previously worked with LexisNexis, Hitwise and Versent

.image ./images/arch.jpg

##
.image images/hiring.jpeg

## Socials
* Threetoes on [Minds](https://minds.com/threetoes) and [Github](https://github.com/threetoes)
* [LinkedIn](https://www.linkedin.com/in/stephen-gream-20676445/)
* [My blog](https://stephengream.com)

##
These slides and code available at [https://github.com/threetoes/golang-talk](https://github.com/threetoes/golang-talk)

## What we're going to look at
* Why Go is great for pentest tooling
* Hiding data in PNG files
* Port scanning remote hosts
* Encrypting data
* gRPC RAT
* Further reading

## Why is Golang great for writing pentesting tools?
* Modern language
* Very extensive built in libraries
* Both high and low level operations are well supported

.image images/gopher_crim.png

## Steganography with PNG

.image images/twitter.png

##
We're not going to do it the same way, but it'll still be fun

## The PNG format
* 8 byte header
* `IHDR` Image header chunk
* Metadata chunks
* `IDAT` Data chunks
* `IEND` EOF chunk

## PNG Chunks
* 4 bytes for chunk size
* 4 bytes for chunk type
* Data bytes
* 4 bytes for CRC

.image images/png_hex.png

## Parsing a chunk

.play snippets/chunkparse/chunk_parse.go /^func ReadChunk/,/^}/

## Inserting our own payload
.image images/insert_chunk.png

## Inserting our own payload

.code ../pnghider/pnghider.go /^func HidePayload/,/^}/
: Encode
: cd ~/code/golang-talk/pnghider && go run cmd/main.go -in ./test.png -out ~/sneaky.png -type sNKY -payload "We're ready to hide from nosey sysadmins"
: View
: xxd ~/sneaky.png

## Recovering our payload

.code ../pnghider/pnghider.go /^func RecoverPayload/,/^}/
: Decode
: cd ~/code/golang-talk/pnghider && go run cmd/main.go -in ~/sneaky.png -decode -type sNKY -decode

## How do we know what to prod?
* We need a way to know what's running
* Luckily, TCP has a built in mechanism

## TCP Connections

.image ./images/synack.png

## How do we detect an open port?
We connect to it!

.image ./images/cable_gopher.png

## The `net.DialTimeout` function

.play ./snippets/tcpconnect/tcpconnect.go /^func OpenPorts/,/^}/

## Industrial Scale Silliness

.code ../tcpscan/tcpscan.go /^func GetOpenPorts/,/^}/

## Industrial Scale Silliness

.code ../tcpscan/tcpscan.go /START DIALWORKER/,/END DIALWORKER/

: Scan nmap
: pushd ~/code/golang-talk/tcpscan/ && go run cmd/main.go -addr scanme.nmap.org -ports 1-100 && popd

## A quieter way
* Don't bother sending back the `ACK`!
* Check out the [Furious](https://github.com/liamg/furious) tool

.image ./images/refuseack.png

: SYN Scan
: Furious is a Golang tool capable of that

## Hiding your data even better
* Stego is one layer, but what we've been doing is still open for all to see
* Assume anything you send over a wire is going to be caught by an adversary
* Make it hard to read with Go's `crypto` package!

## We're using AES
* AES is a symmetric key cipher
* Strong enough to keep most people out
* It is an NSA backed technology, though...

## The Basics (or how I understand them)
.image ./images/encryption.png

## The Basics
* AES creates a block matrix
* Values are substituted, jumbled around, multiplied and XOR'd
    * Sub bytes
    * Shift rows
    * Mix columns
    * Add round key
* Can use keys of length 128, 192 and 256 bits

: AES creates a substituion box
: Always 4 rows in the state array, number of columns increases with key size
: State array = plaintext
: SubBytes - Substitute with bytes on a lookup table
: ShiftRows - Rows in the state array are transposed
: MixColumns - Combines bytes in the state column
: AddRoundKey - Subkey is combined with state with an XOR operation

## Encrypting a payload
.play ./snippets/encryptor/main.go /^func main/,/^}/

: go run cmd/main.go -encrypt -file test.txt -key "SuperSneaky"
: GCM = Galois/Counter Mode
: GCM provides a nonce/IV

## Decrypting a payload
.play ./snippets/decryptor/main.go /^func main/,/^}/
: go run cmd/main.go -decrypt -file test.txt -key "SuperSneaky"

## General Rules Around Crypto
* Don't implement your own
* Assume someone, somewhere is watching what you do
* If you have to ask if you need it, you need it
* Don't keep keys in the same place as your data

## Let's bring it on home
* We have the pieces
* We'll pull them together in a RAT

.image ./images/ratwizard.jpg

: Make sure to mention that RAT stands for remote access tool

## Protocol Buffers
* A standardised way to serialise structured data
* Specify data structures and services in a declarative DSL
* Generate plumbing

: Binary protocol, forward and backward compatible
: Faster to parse and smaller payloads than plain text

## gRPC
* RPC over HTTP/2
* Good for M2M, not so great for browser clients
* Is built on top of protocol buffers
* Is standardised
    * Go services can talk to Java services, etc

: Uses HTTP/2 streaming

## Defining our API

.code ../c2/spec/innocent_pictures.proto /^syntax/,/;/
.code ../c2/spec/innocent_pictures.proto /^message InnocentPicture/,/^}/

: Define syntax version
: Message needs a name
: Fields have a type and a tag
: Services have functions that use the rpc keyword

.code ../c2/spec/innocent_pictures.proto /^service PictureSharing/,/^}/
.code ../c2/spec/innocent_pictures.proto /^service MemeDealer/,/^}/

## Generate the plumbing
Use `protoc` with `protoc-gen-go` and `protoc-gen-go-grpc` to get
the base classes

`$ protoc --go-grpc_out=. --go_out=. spec/innocent_pictures.proto`

With our specification file, we'll get the output in the `/gen` folder

.code ../c2/gen/innocent_pictures_grpc.pb.go /^type PictureSharingServer interface {/,/^}/

## Implement the service
.code ../c2/picture_server.go /DishMeme/,/^}/

: This function lets the admin send a payload to clients
: The service picks a random file out of the images folder
: Encrypts the payload
: Embeds payload in the image
: Puts it in a list for the client to pick up

## Implement the server
.code ../c2/cmd/server/main.go /^func main/,/^}/

: Flags for address, port and image folder
: Instantiate the implemented service
: Bind to a TCP port
: Create a new gRPC server to listen on the port
: Register the service as both the admin and payload service
: go run cmd/server/main.go -images images

## Implement the client
.code ../c2/cmd/client/main.go /Setup our connection/,/client :=/

: Flags for address and port
: Use grpc.Dial to connect to the server
: Pass the connection to the generated client class

## Implement the client
.code ../c2/cmd/client/main.go /Main loop/,/End main loop/

: Loop and ask for pictures
: Find and decrypt the payload
: Run the command
: Encrypt command's output, hide it in the file and return it to the server
: go run cmd/client/main.go

## Implement the 'admin'
.code ../c2/cmd/admin/main.go /^func main/,/^}/

: Much the same as the other client
: Use the generated client class to call the server
: go run cmd/admin/main.go -payload "ls"
: go run cmd/admin/main.go -payload "cat README.md" -out stolen_file.md

## Further reading
* [Black Hat Go](https://www.bookdepository.com/Black-Hat-Go/9781593278656) by Chris Patten, Tom Steele and Dan Kottman
* [Attacking Network Protocols](https://www.bookdepository.com/Attacking-Network-Protocols-James-Forshaw/9781593277505) by James Forshaw
* [Hacking - The art of Exploitation](https://www.bookdepository.com/Hacking--The-Art-Of-Exploitation--2nd-Edition/9781593271442) by Jon Erickson
* [The art of Deception](https://www.bookdepository.com/The-Art-of-Deception/9780764542800) and [The art of Intrusion](https://www.bookdepository.com/Art-Intrusion-Kevin-D-Mitnick/9780471782667) by Kevin Mitnick et al.

.image ./images/black_hat_go.jpg